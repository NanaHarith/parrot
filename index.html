<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PARROT | KnoxCalls</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@300;400;600&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --brand-orange: #FF8200;
            --brand-navy: #0f172a;
            /* Slate 950 */
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #FFFFFF;
            --text-muted: #94a3b8;
            /* Slate 400 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--brand-navy);
            background-image:
                radial-gradient(circle at 50% 0%, rgba(56, 189, 248, 0.05), transparent 60%),
                /* Subtle Blue top glow */
                radial-gradient(circle at 100% 100%, rgba(255, 130, 0, 0.03), transparent 40%);
            /* Subtle Orange corner */
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            text-align: center;
        }

        /* Branding Container */
        .brand-header {
            margin-bottom: 2rem;
            position: relative;
            display: inline-block;
        }

        /* The "Badge" Lines */
        .brand-header::before,
        .brand-header::after {
            content: "";
            position: absolute;
            top: 50%;
            width: 40px;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--glass-border), transparent);
        }

        .brand-header::before {
            right: 100%;
            margin-right: 15px;
        }

        .brand-header::after {
            left: 100%;
            margin-left: 15px;
        }

        h1 {
            font-family: 'Bebas Neue', sans-serif;
            color: var(--text-main);
            margin: 0;
            font-size: 4rem;
            letter-spacing: 6px;
            /* High spacing like NIGHTWATCH */
            line-height: 1;
            text-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .tagline {
            font-size: 0.8rem;
            letter-spacing: 3px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 5px;
            font-weight: 600;
        }

        /* CARD Container (Glassmorphism) */
        .container {
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            padding: 3rem 2.5rem;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        /* Subtle orange top border like login inputs often hav focus */
        .container::top {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--brand-orange), transparent);
            opacity: 0.5;
        }

        /* Input Styling */
        .input-group {
            margin-bottom: 25px;
            text-align: left;
        }

        .input-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            font-size: 1rem;
            color: white;
            font-family: 'Inter', sans-serif;
            box-sizing: border-box;
            transition: all 0.2s;
        }

        input[type="text"]:focus {
            border-color: var(--brand-orange);
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 130, 0, 0.2);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Main Action Button */
        button.main-btn {
            border: none;
            padding: 16px;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #ff8200 0%, #e67300 100%);
            color: white;
            letter-spacing: 0.5px;
            box-shadow: 0 10px 15px -3px rgba(255, 130, 0, 0.3);
            text-transform: uppercase;
        }

        button.main-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 20px 25px -5px rgba(255, 130, 0, 0.4);
            filter: brightness(1.1);
        }

        button.main-btn:active {
            transform: translateY(1px);
        }

        #recordBtn.recording {
            background: transparent;
            border: 1px solid #ef4444;
            /* Red-500 */
            color: #ef4444;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
            animation: pulse-red 2s infinite;
        }

        /* Secondary Buttons (Glass) */
        .actions-area {
            display: flex;
            gap: 12px;
            margin-top: 10px;
            display: none;
        }

        .action-btn {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--glass-border);
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.85rem;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: white;
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Live Feed */
        #liveTranscript {
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            height: 100px;
            overflow-y: auto;
            font-size: 0.85rem;
            color: var(--brand-orange);
            font-family: 'Inter', monospace;
            display: none;
            border: 1px dashed var(--glass-border);
        }

        #liveTranscript small {
            display: block;
            color: var(--text-muted);
            margin-bottom: 5px;
            font-size: 0.7rem;
            letter-spacing: 1px;
        }

        .utilities {
            display: none;
        }

        /* Footer */
        .footer {
            margin-top: 3rem;
            color: #475569;
            /* Slate 600 */
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .footer span {
            color: var(--brand-orange);
        }

        #status {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 15px;
            height: 20px;
        }

        #debug {
            color: #334155;
            font-size: 0.7rem;
            font-family: monospace;
            margin-top: 10px;
        }

        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
                border-color: #ef4444;
            }

            50% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
                border-color: #f87171;
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
                border-color: #ef4444;
            }
        }
    </style>
</head>

<body>

    <div class="brand-header">
        <h1>PARROT</h1>
        <div class="tagline">Audio Intelligence System</div>
    </div>

    <div class="container">
        <div class="input-group">
            <label for="userKey">Operation ID / Target</label>
            <input type="text" id="userKey" placeholder="Enter session identifier..." autocomplete="off" />
        </div>

        <div id="liveTranscript">
            <small>LIVE FEED //</small>
            <div id="liveTextContent"></div>
        </div>

        <button id="recordBtn" class="main-btn">Initialize Recording</button>

        <!-- Download Section -->
        <div id="actionArea" class="actions-area">
            <button id="dlAudio" class="action-btn">
                <span>sc_audio.webm</span>
            </button>
            <button id="dlText" class="action-btn">
                <span>transcript.json</span>
            </button>
        </div>

        <div id="status">Standby</div>
        <div id="debug"></div>
    </div>

    <div class="footer">
        POWERED BY <span>KNOXCALLS</span>
    </div>

    <!-- Hidden Result Container for Logic Compatibility -->
    <div id="result" style="display:none;"></div>

    <script>
        // --- CONFIGURATION ---
        const WEBHOOK_URL = 'https://primary-production-bae0f.up.railway.app/webhook/record-meeting';
        // ---------------------

        // --- GLOBAL STATE ---
        let mediaRecorder;
        let audioChunks = [];
        let globalStream = null;
        let wakeLock = null;
        let recognition = null;

        // DB State
        let db = null;
        const DB_NAME = 'MeetingRecorderDB';
        const STORE_NAME = 'recordings';

        // Download State
        let currentAudioBlob = null;
        let currentAudioExt = 'webm';
        let currentSummaryData = null;
        let hasUnsavedData = false;
        let finalTranscriptText = "";

        // UI Elements
        const recordBtn = document.getElementById('recordBtn');
        const statusEl = document.getElementById('status');
        const debugEl = document.getElementById('debug');
        const resultEl = document.getElementById('result');
        const actionArea = document.getElementById('actionArea');
        const dlAudioBtn = document.getElementById('dlAudio');
        const dlTextBtn = document.getElementById('dlText');
        const userKeyInput = document.getElementById('userKey');
        const liveTranscriptEl = document.getElementById('liveTranscript');
        const liveTextContent = document.getElementById('liveTextContent');

        // --- INITIALIZATION ---
        window.addEventListener('load', async () => {
            await initDB();
            checkUnsavedRecordings();
        });

        // --- DATABASE (IndexedDB) ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onerror = e => console.error('DB Error', e);
                request.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = e => {
                    db = e.target.result;
                    resolve();
                };
            });
        }

        async function saveChunkToDB(chunk) {
            if (!db) return;
            const tx = db.transaction([STORE_NAME], 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const id = 'current_recording';
            try {
                const existing = await getFromDB(id);
                const newChunks = existing ? [...existing.chunks, chunk] : [chunk];
                store.put({ id: id, chunks: newChunks, date: new Date() });
            } catch (e) { console.error('Save failed', e); }
        }

        function getFromDB(id) {
            return new Promise(resolve => {
                const tx = db.transaction([STORE_NAME], 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const req = store.get(id);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
        }

        async function clearDB() {
            if (!db) return;
            const tx = db.transaction([STORE_NAME], 'readwrite');
            tx.objectStore(STORE_NAME).delete('current_recording');
        }

        async function checkUnsavedRecordings() {
            const data = await getFromDB('current_recording');
            if (data && data.chunks && data.chunks.length > 0) {
                const restore = confirm("UNSAVED DATA FOUND (" + data.date.toLocaleString() + "). RESTORE?");
                if (restore) {
                    audioChunks = data.chunks;
                    currentAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    hasUnsavedData = true;
                    actionArea.style.display = 'flex';
                    statusEl.textContent = "DATA RESTORED";
                } else {
                    clearDB();
                }
            }
        }

        // --- WAKE LOCK ---
        async function requestWakeLock() {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
            } catch (err) { }
        }

        // --- LIVE TRANSCRIPT ---
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscriptText += event.results[i][0].transcript + ' ';
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    liveTextContent.innerText = finalTranscriptText + interimTranscript;
                    liveTranscriptEl.scrollTop = liveTranscriptEl.scrollHeight;
                };
            }
        }

        // --- LOGIC ---
        async function initMic() {
            if (globalStream) return globalStream;
            try {
                globalStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                return globalStream;
            } catch (err) {
                alert("MIC ACCESS DENIED");
                return null;
            }
        }

        recordBtn.addEventListener('click', async () => {
            if (!recordBtn.classList.contains('recording') && hasUnsavedData) {
                if (!confirm("OVERWRITE CURRENT DATA?")) return;
                hasUnsavedData = false;
                actionArea.style.display = 'none';
                resultEl.style.display = 'none';
                clearDB(); // Clear backup
            }

            if (recordBtn.classList.contains('recording')) {
                stopRecording();
                return;
            }

            startRecording();
        });

        async function startRecording() {
            const stream = await initMic();
            if (!stream) return;

            audioChunks = [];
            finalTranscriptText = "";
            liveTextContent.innerText = "";
            liveTranscriptEl.style.display = 'block';

            requestWakeLock();
            await clearDB();
            initSpeechRecognition();
            if (recognition) recognition.start();

            const mimeType = 'audio/webm';
            mediaRecorder = new MediaRecorder(stream, { mimeType });

            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                    saveChunkToDB(event.data);
                }
            };

            mediaRecorder.onstop = sendData;
            mediaRecorder.start(1000);

            recordBtn.textContent = "STOP RECORDING";
            recordBtn.classList.add('recording');
            statusEl.textContent = "RECORDING ACTIVE";
            debugEl.textContent = `SESSION: ${userKeyInput.value || 'ANONYMOUS'}`;
            resultEl.style.display = 'none';
            actionArea.style.display = 'none';
        }

        function stopRecording() {
            mediaRecorder.stop();
            if (globalStream) {
                globalStream.getTracks().forEach(track => track.stop());
                globalStream = null;
            }
            if (wakeLock) wakeLock.release();
            if (recognition) recognition.stop();
            recordBtn.textContent = "PROCESSING DATA...";
        }

        async function sendData() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            currentAudioBlob = audioBlob;

            if (audioBlob.size < 2000) {
                alert("RECORDING TOO SHORT");
                resetUI();
                return;
            }

            actionArea.style.display = 'flex';
            statusEl.textContent = "UPLOADING TO CLOUD...";
            recordBtn.disabled = true;
            recordBtn.classList.remove('recording');

            try {
                const headers = { 'Content-Type': 'video/webm' };
                const sessionKey = userKeyInput.value.trim();
                if (sessionKey) headers['X-User-Session'] = sessionKey;

                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: headers,
                    body: audioBlob
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                resetUI();
                statusEl.textContent = "UPLOAD SUCCESSFUL";
                hasUnsavedData = true;
                renderResponse(data);

            } catch (error) {
                statusEl.innerHTML = `<span style='color:#ef4444'>ERROR: UPLOAD FAILED</span>`;
                resetUI();
            }
        }

        function resetUI() {
            recordBtn.textContent = "NEW RECORDING";
            recordBtn.disabled = false;
            recordBtn.classList.remove('recording');
        }

        function renderResponse(data) {
            currentSummaryData = data;
            let json = data;
            if (typeof data.summary === 'string' && data.summary.startsWith('```')) {
                try {
                    const clean = data.summary.replace(/```json/g, '').replace(/```/g, '');
                    json = JSON.parse(clean);
                    currentSummaryData = { ...data, summary: json };
                } catch (e) { }
            }
            // No result display in this UI, but we store data for download
        }

        // --- DOWNLOADS ---
        dlAudioBtn.addEventListener('click', () => {
            if (!currentAudioBlob) return;
            downloadBlob(currentAudioBlob, `parrot-log-${getTimestamp()}.webm`);
        });

        dlTextBtn.addEventListener('click', () => {
            let content = "";
            let ext = "txt";
            let isJson = false;

            if (currentSummaryData) {
                if (currentSummaryData.transcript) {
                    const t = currentSummaryData.transcript;
                    if (Array.isArray(t)) {
                        content = t.map(line => `[${line.speaker || 'UNK'}] ${line.timestamp || ''}\n${line.text}`).join('\n\n');
                    } else {
                        content = t;
                    }
                } else {
                    // Fallback to summary
                    if (currentSummaryData.summary || currentSummaryData.action_items) {
                        const title = currentSummaryData.meeting_title || "Summary";
                        content = `=== ${title.toUpperCase()} ===\n\n`;
                        if (currentSummaryData.summary) {
                            const s = currentSummaryData.summary;
                            content += "--- SUMMARY ---\n";
                            content += (typeof s === 'object') ? JSON.stringify(s, null, 2) : s;
                            content += "\n\n";
                        }
                        if (currentSummaryData.action_items) {
                            content += "--- ACTION ITEMS ---\n";
                            currentSummaryData.action_items.forEach(item => {
                                const task = item.task || item;
                                content += `- ${task}\n`;
                            });
                        }
                    } else {
                        content = JSON.stringify(currentSummaryData, null, 2);
                        ext = "json";
                        isJson = true;
                    }
                }
            } else if (finalTranscriptText) {
                content = "LOCAL TRANSCRIPT:\n\n" + finalTranscriptText;
            } else {
                return;
            }

            const blob = new Blob([content], { type: isJson ? 'application/json' : 'text/plain' });
            downloadBlob(blob, `parrot-intel-${getTimestamp()}.${ext}`);
        });

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function getTimestamp() {
            return new Date().toISOString().slice(0, 19).replace(/:/g, "-");
        }
    </script>

</body>

</html>